From 8ff6bf29e17693078124568817b7aa39e0e3ebbc Mon Sep 17 00:00:00 2001
From: Tim S <stahta01@users.sourceforge.net>
Date: Thu, 15 Nov 2018 21:29:12 -0500
Subject: [PATCH 3/5] gcc6809: Add binutils folder from gcc6809

---
 binutils/Makefile   |  14 +
 binutils/ar         | 231 ++++++++++++++
 binutils/as         | 224 ++++++++++++++
 binutils/ld         | 352 +++++++++++++++++++++
 binutils/ranlib.c   | 726 ++++++++++++++++++++++++++++++++++++++++++++
 binutils/zlibarch.h |  72 +++++
 6 files changed, 1619 insertions(+)
 create mode 100644 binutils/Makefile
 create mode 100644 binutils/ar
 create mode 100644 binutils/as
 create mode 100644 binutils/ld
 create mode 100644 binutils/ranlib.c
 create mode 100644 binutils/zlibarch.h

diff --git a/binutils/Makefile b/binutils/Makefile
new file mode 100644
index 0000000..85ef028
--- /dev/null
+++ b/binutils/Makefile
@@ -0,0 +1,14 @@
+CFLAGS = -O2 -Wall -Wextra -ansi -pedantic -D_XOPEN_SOURCE=700
+
+.PHONY: all
+all: ranlib
+
+.PHONY: clean
+clean:
+	rm -f ranlib
+
+.PHONY: distclean
+distclean: clean
+
+ranlib: ranlib.c
+	$(CC) $(CFLAGS) $(BINUTILS_CFLAGS) -o $@ $< $(BINUTILS_LDFLAGS)
diff --git a/binutils/ar b/binutils/ar
new file mode 100644
index 0000000..ff7e48e
--- /dev/null
+++ b/binutils/ar
@@ -0,0 +1,231 @@
+#!/bin/sh
+#
+# Copyright 2006 by Brian Dominy <brian@oddchange.com>
+#
+# Changes by David Flamand <dflamand@gmail.com> (June 2016)
+#  - cleanup, more robust and verbose in case of error
+#
+# This file is part of GCC6809.
+#
+# GCC6809 is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# GCC6809 is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC6809; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# This script is a frontend to the aslib library manager, to make it
+# look more like GNU ar.  Not all ar features are supported here.
+# It basically translates ar style options into aslib format.
+
+set -e
+IFS=' '
+
+as_prefix=@AS_PREFIX@
+bindir=${as_prefix}/bin
+
+showversion () {
+cat <<END
+ar (m6809) [GNU archiver frontend] 0.3 20160608
+This program is free software; you may redistribute it under the terms of
+the GNU General Public License.  This program has absolutely no warranty.
+END
+}
+
+# Output a message to stderr and exit with a failure code.
+error ()
+{
+	echo "ar (m6809): $1" >&2
+	if [ -z "$2" ]; then
+		exit 1
+	fi
+}
+
+# Strip directory from path.
+basename()
+{
+	printf "%s" "${1##*/}"
+}
+
+# Strip filename from path.
+dirname()
+{
+	name=${1##*/}
+	name=${1%$name}
+	printf "%s" "${name:-.}"
+}
+
+# Install or uninstall library cache.
+libcachetool ()
+{
+	install=$1; shift
+
+	if [ $# = 0 ]; then
+		error "no file given"
+	fi
+	if [ $# -gt 1 ]; then
+		shift
+		error "extra garbage '$*'"
+	fi
+
+	libpathname=$1
+	if [ "$install" = 1 -a ! -f "$libpathname" ]; then
+		error "no such file '$libpathname'"
+	fi
+
+	libfile=`basename "$libpathname"`
+	libdir=`dirname "$libpathname"`
+	lib=${libfile%.*}
+	tmplibfile=$libfile.tmp
+	libcache=${lib}-cache
+	tmplibcache=$libcache.tmp
+
+	if [ ! -d "$libdir" ]; then
+		error "no such directory '$libdir'"
+	fi
+	cd "$libdir"
+
+	# Check if library file exist
+	if [ ! -f "$libfile" ]; then
+		error "'$libfile' does not exist in '$libdir'"
+	fi
+
+	if [ "$install" = 1 ]; then
+		### '--cache' option ###
+
+		# Check for cache directory
+		if [ -d "$libcache" ]; then
+			error "directory '$libcache' already exist"
+		fi
+
+		# Recreate the cache directory
+		rm -rf "$tmplibcache"
+		mkdir -p "$tmplibcache"
+
+		# Fill the cache
+		cd "$tmplibcache"
+		if ! $bindir/aslib x "../$libfile"; then
+			cd ..
+			rm -rf "$tmplibcache"
+			exit 1
+		fi
+		cd ..
+
+		# Overwrite cache with temp cache
+		rm -rf "$libcache"
+		mv "$tmplibcache" "$libcache"
+
+		# Make the index file
+		find "$libcache" -name '*.o' | LC_ALL=C sort >"$libfile"
+	else
+		### '--uncache' option ###
+
+		# Check for cache directory
+		if [ ! -d "$libcache" ]; then
+			error "directory '$libcache' does not exist"
+		fi
+
+		# Separator set to newline
+		IFS='
+'
+		# Generate a list of object file
+		objects=`cat $libfile`
+
+		# Remove temp file
+		rm -f "$tmplibfile"
+
+		# Rename old library file
+		mv "$libfile" "$tmplibfile"
+
+		# Build a new library from object file
+		cd "$libcache"
+		if ! $bindir/aslib qc "../$libfile" $objects; then
+			cd ..
+			rm -rf "$libfile"
+			mv "$tmplibfile" "$libfile"
+			exit 1
+		fi
+		cd ..
+
+		# Removing cache directory and library file
+		rm -rf "$libcache" "$tmplibfile"
+	fi
+
+	exit
+}
+
+# Reorder and remove duplicate option letter.
+options=${1#-}
+prefix=${1%$options}
+if [ "$options" = "${options#-}" ]; then
+	error=; c=; d=; p=; q=; r=; t=; u=; v=; x=
+	while [ -n "$options" ]; do
+		remain=${options#?}
+		letter=${options%$remain}
+		case $letter in
+			c) c=c;; d) d=d;; p) p=p;;
+			q) q=q;; r) r=r;; t) t=t;;
+			u) u=u;; v) v=v;; x) x=x;;
+			*) error=X; error "invalid option -- '$letter'" X;;
+		esac
+		options=$remain
+	done
+	if [ -n "$error" ]; then
+		exit 1
+	fi
+	options=$c$d$p$q$r$t$u$v$x
+fi
+
+# Make sure we have an option.
+if [ -z "$options" ]; then
+	error "no options given"
+fi
+
+# Parse and translate command-line options.
+shift
+case $options in
+############################################################
+# these are custom archiver options (no GNU ar equivalent) #
+	-cache)
+		libcachetool 1 "$@"
+		;;
+	-uncache)
+		libcachetool 0 "$@"
+		;;
+############################################################
+	-version)
+		showversion
+		exit 0
+		;;
+	-help)
+		cat $0 # TODO
+		exit 0
+		;;
+	cru)
+		options="cr"
+		;;
+	cruv)
+		options="crv"
+		;;
+	cr|crv|d|dv|p|pv|q|qv|r|rv|t|tv|vx|x)
+		;;
+	*)
+		error "invalid options '$prefix$options'"
+		;;
+esac
+
+# Make sure we have an archive.
+if [ -z "$1" ]; then
+	error "no archive given"
+fi
+
+# Invoke the real assembler with translated options.
+exec $bindir/aslib $options "$@"
diff --git a/binutils/as b/binutils/as
new file mode 100644
index 0000000..f249309
--- /dev/null
+++ b/binutils/as
@@ -0,0 +1,224 @@
+#!/bin/sh
+#
+# Copyright 2006 by Brian Dominy <brian@oddchange.com>
+#
+# Changes by David Flamand <dflamand@gmail.com> (June 2016)
+#  - more robust and verbose in case of error
+#
+# This file is part of GCC6809.
+#
+# GCC6809 is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# GCC6809 is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC6809; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# This script is a frontend to the as6809 assembler, to make it
+# look more like GNU as.  Not all as features are supported here.
+# It basically translates as style options into as6809 format.
+
+set -e
+IFS=' '
+
+as_prefix=@AS_PREFIX@
+bindir=${as_prefix}/bin
+
+showversion () {
+cat <<END
+as (m6809) [GNU assembler frontend] 0.3 20160608
+This program is free software; you may redistribute it under the terms of
+the GNU General Public License.  This program has absolutely no warranty.
+END
+}
+
+# Output a message to stderr and exit with a failure code.
+error ()
+{
+	echo "as (m6809): $1" >&2
+	exit 1
+}
+
+# Assume nothing.
+input_file=
+list_file=
+gen_list_file=
+verbose=
+version=
+
+# Default output filename.
+output_file=a.out
+
+# The -o option causes an object file to be created.
+# The -g option causes undefined symbols to be made global.
+options=-og
+
+# Parse the command-line options.  See the GNU 'as' man page for
+# an explanation of all these options.  Our goal is to translate
+# them into as6809 form.
+while [ $# -gt 0 ]; do
+	arg=$1; shift
+	case $arg in
+############################################################
+# these are custom assember options (no GNU as equivalent) #
+		-m6809)
+			true
+			;;
+		-gn)
+			# Generate NoICE debug symbols
+			options="${options}j"
+			;;
+		-gs)
+			# Generate SDCC debug symbols
+			options="${options}y"
+			;;
+############################################################
+		--globalize-symbols)
+			# Make all symbols global
+			options="${options}a"
+			;;
+		-m*)
+			error "invalid CPU option '$arg'"
+			;;
+		--)
+			error "standard input not supported"
+			;;
+		-a*)
+			options="${options}lc"
+			gen_list_file=X
+			;;
+		-I)
+			if [ $# -lt 1 ]; then
+				error "missing path after '$arg'"
+			fi
+#			include_file=$1
+#			echo "warning: include path '$include_file' ignored"
+			shift
+			;;
+		-I*)
+#			include_file=${arg#-I}
+#			echo "warning: include path '$include_file' ignored"
+			;;
+		-MD)
+			error "assembler option '$arg' not supported"
+			;;
+		-o)
+			output_file=$1; shift
+			;;
+		-v|-verbose|--verbose)
+			verbose=X
+			;;
+		-version|--version)
+			version=X
+			;;
+		-help|--help)
+			cat $0 # TODO
+			exit 0
+			;;
+		-D|-f|-K|--traditional-format|-w|-x|-Z|-W|--no-warn)
+			# These options are accepted but ignored by GNU as.
+			true
+			;;
+		=*)
+			# Set the name of the listing file
+			list_file=${arg#=}
+			;;
+		-*)
+			error "unrecognized option '$arg'"
+			;;
+		*)
+			if [ -n "$input_file" ]; then
+				error "more than one input file specified"
+			fi
+			if [ "${arg%.*}" = "$arg" ]; then
+				error "input file '$arg' without extension"
+			fi
+			input_file=$arg
+			;;
+	esac
+done
+
+# Setup various file name.
+asoutput_file=${input_file%\.*}.rel
+if [ -n "$gen_list_file" ]; then
+	aslist_file=${input_file%\.*}.lst
+	if [ -z "$list_file" ]; then
+		list_file=$aslist_file
+	fi
+fi
+
+# Output version information.
+if [ -n "$version" -o -n "$verbose" ]; then
+	showversion
+fi
+if [ -n "$version" ]; then
+	exit 0
+fi
+
+# Output more information when --verbose option is set.
+if [ -n "$verbose" ]; then
+	echo "$bindir/as6809 $options $input_file"
+	echo "Output file: '$output_file'"
+	if [ -n "$gen_list_file" ]; then
+		echo "List file: '$list_file'"
+	fi
+fi
+
+# Exit if no input files given.
+# We don't support redirecting from standard input.
+if [ -z "$input_file" ]; then
+	if [ -n "$verbose" ]; then
+		exit 0
+	fi
+	error "no input file specified"
+fi
+
+set +e
+
+# Invoke the real assembler with translated options.
+$bindir/as6809 $options "$input_file"
+rc=$?
+
+set -e
+
+# OK, see if the assembler succeeded or not.
+# If it failed, the source is copied to /tmp/as6809_error.s
+# so that it can be inspected.  GCC will normally delete any
+# temporary .s files that it generates.  This makes debugging
+# the compiler easier.
+#
+# Also, as6809 still creates a .o file even on an error;
+# that can confuse 'make'.  So delete the output file.
+if [ "$rc" != "0" ]; then
+	# Make sure that the input file is valid before copying.
+	if [ -f "$input_file" ]; then
+		cp -p "$input_file" /tmp/as6809_error.s || true
+	fi
+	rm -f "$asoutput_file"
+	if [ -n "$gen_list_file" ]; then
+		rm -f "$aslist_file"
+	fi
+	exit $rc
+fi
+
+# as6809 creates the output file with the same name as the
+# input file, but with a .rel extension.  The user may want
+# a different filename altogether, so honor that request here.
+if [ "$asoutput_file" != "$output_file" ]; then
+	mv "$asoutput_file" "$output_file"
+fi
+
+# Same as above but for the list file with a .lst extension.
+if [ -n "$gen_list_file" -a "$aslist_file" != "$list_file" ]; then
+	mv "$aslist_file" "$list_file"
+fi
+
+exit 0
diff --git a/binutils/ld b/binutils/ld
new file mode 100644
index 0000000..0be37e1
--- /dev/null
+++ b/binutils/ld
@@ -0,0 +1,352 @@
+#!/bin/sh
+#
+# Copyright 2006, 2007 by Brian Dominy <brian@oddchange.com>
+#
+# Changes by David Flamand <dflamand@gmail.com> (June 2016)
+#  - added more options, more robust and verbose in case of error
+#
+# This file is part of GCC6809.
+#
+# GCC6809 is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# GCC6809 is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC6809; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+
+# This script is a frontend to the aslink object linker, to make it
+# look more like GNU ld.  Not all ld features are supported here.
+# It basically translates ld style options into aslink format.
+
+set -e
+IFS=' '
+
+as_prefix=@AS_PREFIX@
+bindir=${as_prefix}/bin
+
+showversion () {
+cat <<END
+ld (m6809) [GNU linker frontend] 0.3 20160608
+This program is free software; you may redistribute it under the terms of
+the GNU General Public License.  This program has absolutely no warranty.
+END
+}
+
+# Output an error message to stderr and exit with a failure code.
+error ()
+{
+	echo "ld (m6809): $1" >&2
+	exit 1
+}
+
+# Check if a given filename will survive a variable expansion.
+checkfilename ()
+{
+	MSG=$1; shift
+	OIFS=$IFS; IFS=/
+	A=$1; shift; B=$*
+	IFS=$OIFS
+	if [ -z "$A" -o "$A" != "$B" ]; then
+		error "$MSG '$A'"
+	fi
+}
+
+# Set output format.
+setformat ()
+{
+	case $1 in
+		s19)	# Motorola S Record 
+			aslink_options="${aslink_options}o"
+			exe_suffix=$1
+			;;
+		bin)	# Tandy CoCo Disk BASIC binary
+			aslink_options="${aslink_options}t"
+			exe_suffix=$1
+			;;
+		ihx)	# Intel Hex
+			aslink_options="${aslink_options}i"
+			exe_suffix=$1
+			;;
+		*)
+			error "unrecognized output format '$1'"
+			;;
+	esac
+}
+
+# Assume nothing.
+args=
+asmap_file=
+asoutput_file=
+crt0_file=
+exe_suffix=
+gen_map_file=
+input_files=
+libpaths=
+libs=
+map_file=
+noargs=
+options=
+target=
+verbose=
+version=
+
+# Set defaults.
+aslink_options=-nwxsar
+output_file=a.out
+
+# Try to guest the target type, which is determined
+# by the name by which the program was invoked.
+case ${0##*/} in
+	coco-*|*-coco-*|*-coco)
+		options="-b .text=0x2000 -b .data=0x7000 -b .bss=0x7C00 -b .ctors=0x7F00 -b .dtors=0x7F80 -b .vector=0x7FF0"
+		target=coco
+		setformat bin
+		LD_NOARGS=X
+		;;
+	sim-*|*-sim-*|*-sim)
+		options="-b .text=0x10 -b .vector=0xFFF0"
+		target=sim
+		setformat s19
+		LD_NOARGS=X
+		;;
+	*)
+		options="-b .vector=0xFFF0"
+		target=unknown
+		setformat s19
+		LD_NOARGS=X # default to noargs for now
+		;;
+esac
+
+# Parse and translate command-line options.
+while [ $# -gt 0 ]; do
+	arg=$1; shift
+	case $arg in
+##########################################################
+# these are custom linker options (no GNU ld equivalent) #
+		-gn)
+			# Generate NoICE debug file
+			aslink_options="${aslink_options}j"
+			;;
+		-gs)
+			# Generate SDCDB debug file
+			aslink_options="${aslink_options}y"
+			;;
+		--map)
+			# Generate map file
+			gen_map_file=X
+			;;
+		--args)
+			# Prototype of main():
+			#  if supplied main() prototype is
+			#    int main(int argc, char **argc)
+			#  if not supplied main() prototype is
+			#    int main(void)
+			args=X
+			;;
+		--noargs)
+			# The inverse of the above
+			noargs=X
+			;;
+		-Tcode)
+			# Same as -Ttext
+			options="$options -b .text=$1"; shift
+			;;
+##########################################################
+		-o|--output)
+			output_file=$1; shift
+			;;
+		--output=*)
+			output_file=${arg#*=}
+			;;
+		-L|--library-path)
+			path=$1; shift
+			checkfilename "invalid library path" "$path" $path
+			libpaths="$libpaths -k $path"
+			;;
+		-L*)
+			path=${arg#-L}
+			checkfilename "invalid library path" "$path" $path
+			libpaths="$libpaths -k $path"
+			;;
+		--library-path=*)
+			path=${arg#*=}
+			checkfilename "invalid library name" "$path" $path
+			libpaths="$libpaths -k $path"
+			;;
+		-l|--library)
+			name=$1; shift
+			checkfilename "invalid library name" "$name" $name
+			libs="$libs -l lib$name.a"
+			;;
+		-l*)
+			name=${arg#-l}
+			checkfilename "invalid library name" "$name" $name
+			libs="$libs -l lib$name.a"
+			;;
+		--library=*)
+			name=${arg#*=}
+			checkfilename "invalid library name" "$name" $name
+			libs="$libs -l lib$name.a"
+			;;
+		--section-start)
+			options="$options -b $1"; shift
+			;;
+		--section-start=*)
+			options="$options -b ${arg#*=}"
+			;;
+		--defsym)
+			options="$options -g $1"; shift
+			;;
+		--defsym=*)
+			options="$options -g ${arg#*=}"
+			;;
+		--oformat)
+			setformat "$1"; shift
+			;;
+		--oformat=*)
+			setformat "${arg#*=}"
+			;;
+		-Tbss)
+			options="$options -b .bss=$1"; shift
+			;;
+		-Tdata)
+			options="$options -b .data=$1"; shift
+			;;
+		-Ttext)
+			options="$options -b .text=$1"; shift
+			;;
+		-g)
+			# Ignored by GNU ld; we should do the same
+			true
+			;;
+		-v|-verbose|--verbose)
+			verbose=X
+			;;
+		-version|--version)
+			version=X
+			;;
+		-help|--help)
+			cat $0 # TODO
+			exit 0
+			;;
+		-T)
+			options="$options -f $1"; shift
+			;;
+		-Map|--Map)
+			map_file=$1; shift
+			gen_map_file=X
+			;;
+		-Map=*|--Map=*)
+			map_file=${arg#*=}
+			gen_map_file=X
+			;;
+		-*)
+			error "unrecognized option '$arg'"
+			;;
+		*/crt0.o|crt0.o)
+			checkfilename "invalid input file name" "$arg" $arg
+			if [ -n "$crt0_file" ]; then
+				error "more than one crt0.o given"
+			fi
+			crt0_file=$arg
+			;;
+		*)
+			checkfilename "invalid input file name" "$arg" $arg
+			if [ "${arg%.*}" = "$arg" ]; then
+				error "input file '$arg' without extension"
+			fi
+			input_files="$input_files $arg"
+			;;
+	esac
+done
+
+# Setup various file name.
+asoutput_file=${output_file%\.*}.$exe_suffix
+asmap_file=${asoutput_file%\.*}.map
+if [ -z "$map_file" ]; then
+	map_file=${output_file%\.*}.map
+fi
+if [ -n "$gen_map_file" ]; then
+	aslink_options="${aslink_options}m"
+fi
+
+# Handle --noargs and --args option.
+if [ -n "$args" ]; then
+	noargs=
+elif [ -z "$noargs" ]; then
+	noargs=$LD_NOARGS # from target or from environment variable
+fi
+# $noargs non-empty, so define __argc and __argv to NULL.
+if [ -n "$noargs" ]; then
+	options="$options -g __argc=0 -g __argv=0"
+fi
+
+# Output version information.
+if [ -n "$version" -o -n "$verbose" ]; then
+	showversion
+fi
+if [ -n "$version" ]; then
+	exit 0
+fi
+
+# Output more information when --verbose option is set.
+if [ -n "$verbose" ]; then
+	echo "$bindir/aslink $aslink_options $options $asoutput_file $crt0_file $input_files $libpaths $libs"
+	echo "Target: '$target'"
+	echo "Output format: '$exe_suffix'"
+	echo "Output file: '$output_file'"
+	if [ -n "$gen_map_file" ]; then
+		echo "Map file: '$map_file'"
+	fi
+fi
+
+# Exit if no input files given.
+if [ -z "$input_files" ]; then
+	if [ -n "$verbose" ]; then
+		exit 0
+	fi
+	error "no input files"
+fi
+
+if [ -n "$gen_map_file" -a -e "$asmap_file" ]; then
+	rm -f "$asmap_file"
+fi
+
+set +e
+
+# Invoke the real linker with translated options.
+$bindir/aslink $aslink_options $options "$asoutput_file" $crt0_file $input_files $libpaths $libs
+rc=$?
+
+set -e
+
+# Do some cleanup in case of error.
+if [ "$rc" != "0" ]; then
+	rm -f "$asoutput_file"
+	if [ -n "$gen_map_file" -a -e "$asmap_file" ]; then
+		rm -f "$asmap_file"
+	fi
+	exit $rc
+fi
+
+# aslink creates the output file with the same name as the
+# input file, but with a .s19|.bin|.ihx extension.  The user may want
+# a different filename altogether, so honor that request here.
+if [ "$asoutput_file" != "$output_file" ]; then
+	mv "$asoutput_file" "$output_file"
+fi
+
+# Same as above but for the map file with a .map extension.
+if [ -n "$gen_map_file" -a "$asmap_file" != "$map_file" ]; then
+	mv "$asmap_file" "$map_file"
+fi
+
+exit 0
diff --git a/binutils/ranlib.c b/binutils/ranlib.c
new file mode 100644
index 0000000..6b4dd04
--- /dev/null
+++ b/binutils/ranlib.c
@@ -0,0 +1,726 @@
+/*
+ * Copyright 2016 by David Flamand <dflamand@gmail.com>
+ *
+ * This file is part of GCC6809.
+ *
+ * GCC6809 is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GCC6809 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GCC6809; see the file COPYING3.  If not see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <time.h>
+#define ZLIBARCH_STATIC
+#include "zlibarch.h"
+
+
+#define VERSION				"1.0"
+#define ARCHIVE_FORMAT		"DFAR"
+#define ARCHIVE_VERSION		"1"
+#ifndef ARCHIVE_ARCH
+#define ARCHIVE_ARCH		"m6809" /* m6809 */
+#endif
+#ifndef ARCHIVE_MACH
+#define ARCHIVE_MACH		"m6809" /* m6809 or m6309 */
+#endif
+#define TMP_FILE			"/tmp/ranlib.XXXXXX"
+#define OPT_HELP			"--help"
+#define OPT_VERSION			"--version"
+#define OPT_ARCH			"--arch"
+#define OPT_MACH			"--mach"
+#define OPT_NOHASH			"--nohash"
+#define OPT_STRIP			"--strip"
+#define OPT_DETER			"-D"
+#define OPT_NONDETER		"-U"
+#ifdef ZLIBARCH
+#define OPT_GZIP			"--gzip"
+#define OPT_NOGZIP			"--nogzip"
+#endif
+#define HEXBIT				4
+#define HEXLONGSZ			(sizeof(long)*2)
+#define MAX_SYMBOL_SIZE		512
+#define MAX_OBJECT_SIZE		256
+#define MAX_LINE_SIZE		\
+	(MAX_SYMBOL_SIZE + 1 + MAX_OBJECT_SIZE + 1 + HEXLONGSZ + 4)
+#define MIN_HASH_BIT		3
+#define MAX_HASH_BIT		16
+#define MAX_HASH_LINE_SIZE	80
+
+
+typedef struct _symbol_t {
+	struct _symbol_t *next;
+	long offset;
+	char *name;
+	int digit;
+	char *pos;
+	char *nameend;
+} symbol_t;
+
+typedef struct _file_t {
+	struct _file_t *next;
+	char *name;
+} file_t;
+
+
+static FILE *tmpfp;
+static symbol_t **symbols, **symtail;
+static file_t *files, *filtail;
+static char tmpfilename[sizeof(TMP_FILE)];
+static char *opt_arch, *opt_mach, *fname;
+static int hashsize, hashmask;
+static int opt_nohash, opt_strip, opt_deterministic;
+#ifdef ZLIBARCH
+static int opt_gzip;
+#endif
+
+
+static void usage(int error)
+{
+	fprintf(error ? stderr : stdout,
+		"Usage: ranlib [options] archive\n"
+		" The options are:\n"
+		"  "OPT_HELP"\n"
+		"  "OPT_VERSION"\n"
+		"  "OPT_ARCH"=<name>\n"
+		"  "OPT_MACH"=<name>\n"
+		"  "OPT_STRIP"\n"
+		"  "OPT_NOHASH"\n"
+#ifdef ZLIBARCH
+		"  "OPT_GZIP"\n"
+		"  "OPT_NOGZIP"\n"
+#endif
+		"  "OPT_DETER"\n"
+		"  "OPT_NONDETER"\n"
+		);
+	exit(error);
+}
+
+static void version(void)
+{
+	printf(
+		"ranlib ("ARCHIVE_ARCH") "VERSION"\n"
+		"This program is free software; you may redistribute it under the terms of\n"
+		"the GNU General Public License version 3 or (at your option) any later version.\n"
+		"This program has absolutely no warranty.\n"
+		);
+	exit(0);
+}
+
+static void cleanuptemp(void)
+{
+	if (tmpfp != NULL) {
+		FCLOSE(tmpfp);
+		tmpfp = NULL;
+	}
+	if (*tmpfilename != 0) {
+		remove(tmpfilename);
+		*tmpfilename = 0;
+	}
+}
+
+static void error(char *format, ...)
+{
+	va_list ap;
+	fprintf(stderr, "ranlib: ");
+	if (fname)
+		fprintf(stderr, "error while proccessing '%s': ", fname);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fputs("\n", stderr);
+	cleanuptemp();
+	exit(1);
+}
+
+static void *emalloc(size_t size)
+{
+	void *ptr = malloc(size);
+	if (!ptr)
+		error("out of memory");
+	return ptr;
+}
+
+static void *ecalloc(size_t nmemb, size_t size)
+{
+	void *ptr = calloc(nmemb, size);
+	if (!ptr)
+		error("out of memory");
+	return ptr;
+}
+
+static char *estrdup(const char *s)
+{
+	char *str = strdup(s);
+	if (!str)
+		error("out of memory");
+	return str;
+}
+
+static void add_file(char *filename)
+{
+	file_t *file;
+	char *name;
+	file = (file_t *)ecalloc(1, sizeof(file_t));
+	name = estrdup(filename);
+	if (files == NULL)
+		files = filtail = file;
+	else
+		filtail = filtail->next = file;
+	file->name = name;
+}
+
+static int gethashbit(unsigned int number)
+{
+	int bit = 0;
+	if (!opt_nohash) {
+		while (number >>= 1)
+			bit++;
+		if (bit < MIN_HASH_BIT)
+			bit = 0;
+		else
+		if (bit > MAX_HASH_BIT)
+			bit = MAX_HASH_BIT;
+	}
+	return bit;
+}
+
+static int gethexdigit(unsigned long number)
+{
+	int digit = 1;
+	while (number >>= 4)
+		digit++;
+	return digit;
+}
+
+/* djb2 hash function */
+static int djb2hash(char *p)
+{
+	int h;
+	h = 5381;
+	while (*p)
+		h = ((h << 5) + h) + *p++;
+	return h & hashmask;
+}
+
+static long add_symbol(char *symbol, char *object, long offset)
+{
+	symbol_t *sym;
+	char *name;
+	size_t len;
+	int namelen;
+	namelen = strlen(symbol);
+	len = namelen + 1 + strlen(object) + 1 + HEXLONGSZ + 1;
+	sym = (symbol_t *)ecalloc(1, sizeof(symbol_t));
+	name = (char *)emalloc(len + 1);
+	sprintf(name, "%s %s ", symbol, object);
+	if (symbols[0] == NULL)
+		symbols[0] = symtail[0] = sym;
+	else
+		symtail[0] = symtail[0]->next = sym;
+	sym->offset = offset;
+	sym->name = name;
+	sym->pos = name + len - 1 - HEXLONGSZ;
+	sym->nameend = name + namelen;
+	return len;
+}
+
+static void free_symbols(void)
+{
+	int i;
+	symbol_t *symbol, *next;
+	if (symbols != NULL) {
+		for (i=0; i<hashsize; i++) {
+			symbol = symbols[i];
+			while (symbol) {
+				next = symbol->next;
+				free(symbol->name);
+				free(symbol);
+				symbol = next;
+			}
+		}
+		free(symbols);
+		symbols = NULL;
+	}
+	if (symtail != NULL) {
+		free(symtail);
+		symtail = NULL;
+	}
+}
+
+static int striplineend(char *str)
+{
+	int len = strlen(str);
+	if (str[len-1] == '\n')
+		str[--len] = 0;
+	if (len > 0) {
+		if (str[len-1] == '\r')
+			str[--len] = 0;
+	}
+	return len;
+}
+
+static int copy_object(char *buffer, char *object)
+{
+	char *str;
+	size_t len;
+	len = striplineend(object);
+	if (len > 0) {
+		str = strchr(object, ' ');
+		if (str != NULL) {
+			*str = 0;
+			len = strlen(object);
+		}
+		if (len > 0) {
+			strcpy(buffer, object);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static void ranlib(char *filename)
+{
+	FILE *fp, *tmpfpr;
+	char line[MAX_LINE_SIZE], object[MAX_LINE_SIZE], *str, *arch, *mach;
+	long begin, offset, indexsize, objoff, size;
+	unsigned long maxoffset;
+	symbol_t *symbol, *symbol2, *next;
+	int fd, digit, begdigit, diff, changed, h, i, j, err, ret, hashbit;
+	size_t len, len2, nsymbols;
+
+	/* Free previous symbols if any. */
+	free_symbols();
+
+	/* Set current filename for error printing. */
+	fname = filename;
+
+	/* Init ARCH and MACH to NULL */
+	arch = mach = NULL;
+
+	/* Open input file. */
+	fp = FOPEN(filename, "r");
+	if (fp == NULL)
+		error("cannot open archive");
+
+	/* Process header/metadata/comments and skip hash/symbol table if any. */
+	begin = 0;
+	while (FGETS(line, MAX_LINE_SIZE, fp) != NULL) {
+		if (*line == '#') {
+			str = line+1;
+			striplineend(str);
+			if (!strncmp(str, " FORMAT ", sizeof(" FORMAT ")-1)) {
+				if (strcmp(str+sizeof(" FORMAT ")-1, ARCHIVE_FORMAT))
+					error("wrong library format");
+			}
+			else
+			if (!strncmp(str, " VERSION ", sizeof(" VERSION ")-1)) {
+				if (strcmp(str+sizeof(" VERSION ")-1, ARCHIVE_VERSION))
+					error("wrong version number");
+			}
+			else
+			if (!strncmp(str, " ARCH ", sizeof(" ARCH ")-1)) {
+				if (arch == NULL)
+					arch = strdup(str+sizeof(" ARCH ")-1);
+			}
+			else
+			if (!strncmp(str, " MACH ", sizeof(" MACH ")-1)) {
+				if (mach == NULL)
+					mach = strdup(str+sizeof(" MACH ")-1);
+			}
+			begin = FTELL(fp);
+			continue;
+		}
+		do {
+			if (*line == '\n' || *line == '\r' || ((str = strchr(line, ' ')) && strchr(str+1, ' '))) {
+				begin = FTELL(fp);
+				continue;
+			}
+			if (line[0] != 'L' || (line[1] >= '0' && line[1] <= '9'))
+				error("wrong archive format");
+			break;
+		} while (FGETS(line, MAX_LINE_SIZE, fp) != NULL);
+		break;
+	}
+	if (FERROR(fp))
+		error("cannot read file");
+
+	/* The variable 'begin' should point at the beginning of 'LIB' line. */
+	if (begin < 0)
+		error("something goes wrong with header processing");
+
+	/* Create and open temp file. */
+	strcpy(tmpfilename, TMP_FILE);
+	fd = mkstemp(tmpfilename);
+	if (fd < 0)
+		error("cannot create temp file");
+#ifdef ZLIBARCH
+	tmpfp = FDOPEN(fd, (!FDIRECT(fp) && opt_gzip == 0) || (opt_gzip > 0) ? "w" : "wT");
+#else
+	tmpfp = FDOPEN(fd, "r+");
+#endif
+	if (tmpfp == NULL)
+		error("cannot open temp file");
+
+	/* Check for strip option, when set skip symbol table output. */
+	if (!opt_strip) {
+		/* Alloc buffer for symbol table. */
+		symbols = ecalloc(1, sizeof(symbol_t*));
+		symtail = ecalloc(1, sizeof(symbol_t*));
+
+		/* Scan for all defined symbols, and add them to 'symbols'. */
+		*object = 0;
+		objoff = 0;
+		nsymbols = 0;
+		indexsize = 0;
+		offset = FTELL(fp);
+		while (FGETS(line, MAX_LINE_SIZE, fp) != NULL) {
+			if (line[0] == 'E')
+				break;
+			if (line[0] == 'L') {
+				if (line[1] == '0' && line[2] == ' ')
+					objoff = copy_object(object, &line[3]) ? offset - begin : 0;
+				else
+				if (line[1] == '1' && line[2] == ' ')
+					objoff = 0;
+				offset = FTELL(fp);
+				continue;
+			}
+			if (objoff) {
+				if (line[0] == 'S' && line[1] == ' ') {
+					str = strchr(&line[2], ' ');
+					if (str && str != &line[2]) {
+						if (str[1] == 'D') {
+							*str = 0;
+							/* Add only '.__.ABS.' symbol if not defined to zero. */
+							if (!(!strcmp(&line[2], ".__.ABS.") &&
+								(str[2] == 'E' || str[2] == 'e') &&
+								(str[3] == 'F' || str[3] == 'f') &&
+								strtol(&str[4], NULL, 16) == 0)) {
+								indexsize += add_symbol(&line[2], object, objoff);
+								nsymbols++;
+							}
+						}
+					}
+				}
+			}
+			offset = FTELL(fp);
+		}
+		if (FERROR(fp))
+			error("cannot read file");
+
+		/* If hashsize > 1 then compute hash function on symbols
+		   and fill bins. */
+		hashbit = gethashbit(nsymbols);
+		hashsize = 1 << hashbit;
+		if (hashsize > 1) {
+			hashmask = hashsize - 1;
+			symbol = symbols[0];
+			free(symbols);
+			free(symtail);
+			symbols = ecalloc(hashsize, sizeof(symbol_t*));
+			symtail = ecalloc(hashsize, sizeof(symbol_t*));
+			while (symbol) {
+				next = symbol->next;
+				symbol->next = NULL;
+				*symbol->nameend = 0;
+				h = djb2hash(symbol->name);
+				*symbol->nameend = ' ';
+				if (symbols[h] == NULL)
+					symbols[h] = symtail[h] = symbol;
+				else
+					symtail[h] = symtail[h]->next = symbol;
+				symbol = next;
+			}
+			/* For offset zero. */
+			indexsize++;
+			/* Compute indexsize for the number of non-zero bin. */
+			for (i=0; i<hashsize; i++)
+				if (symbols[i])
+					indexsize++;
+		}
+
+		/* Compute the required number of digit for each symbol offset,
+		   iterate until the number of digit stabilize. Two steps: */
+		begdigit = HEXLONGSZ;
+		/* Step 1, find the greatest offset and try to strip digit for all symbols. */
+		do {
+			maxoffset = 0;
+			for (i=0; i<hashsize; i++) {
+				if (symtail[i]) {
+					offset = symtail[i]->offset + indexsize;
+					if (offset > (long)maxoffset)
+						maxoffset = offset;
+				}
+			}
+			digit = 1;
+			while (maxoffset>>=HEXBIT)
+				digit++;
+			diff = begdigit - digit;
+			begdigit = digit;
+			indexsize -= diff * nsymbols;
+			changed = diff;
+		} while (changed);
+		/* Step 2, strip digit for each symbol. */
+		do {
+			changed = 0;
+			for (i=0; i<hashsize; i++) {
+				for (symbol = symbols[i]; symbol; symbol=symbol->next) {
+					maxoffset = symbol->offset + indexsize;
+					digit = 1;
+					while (maxoffset>>=HEXBIT)
+						digit++;
+					diff = (symbol->digit ? symbol->digit : begdigit) - digit;
+					symbol->digit = digit;
+					if (diff) {
+						changed |= diff;
+						for (j=0; j<hashsize; j++)
+							for (symbol2 = symbols[j]; symbol2; symbol2=symbol2->next)
+								symbol2->offset -= diff;
+					}
+				}
+			}
+		} while (changed);
+
+		/* Output header. */
+		err = FPRINTF(tmpfp, 
+			"# FORMAT %s\n"
+			"# VERSION %s\n"
+			, ARCHIVE_FORMAT, ARCHIVE_VERSION) <= 0;
+		if (opt_arch != (char*)-1)
+			err |= FPRINTF(tmpfp, "# ARCH %s\n", opt_arch ? opt_arch : (arch ? arch : ARCHIVE_ARCH)) <= 0;
+		if (opt_mach != (char*)-1)
+			err |= FPRINTF(tmpfp, "# MACH %s\n", opt_mach ? opt_mach : (mach ? mach : ARCHIVE_MACH)) <= 0;
+		if (!opt_deterministic)
+			err |= FPRINTF(tmpfp, "# TIMESTAMP %li\n", time(NULL)) <= 0;
+		if (nsymbols != 0 && hashsize > 1) {
+			ret = FPRINTF(tmpfp, "# HASH %X", hashbit);
+			err |= ret <= 0;
+			len = ret;
+			for (i=0, size=1 /* for zero offset */; i<hashsize && !err; i++) {
+				symbol = symbols[i];
+				len2 = symbol ? gethexdigit(size)+1 : 1+1;
+				len += len2;
+				if (len >= MAX_HASH_LINE_SIZE) {
+					ret = FPRINTF(tmpfp, "\n# HASH");
+					err |= ret <= 0;
+					len = ret-1 + len2;
+				}
+				err |= FPRINTF(tmpfp, " %lX", symbol ? size : 0) <= 0;
+				if (symbol) {
+					for (; symbol; symbol=symbol->next)
+						size += symbol->pos - symbol->name + symbol->digit + 1;
+					size++;
+				}
+			}
+			err |= FPRINTF(tmpfp, "\n") <= 0;
+		}
+		if (err || FERROR(tmpfp))
+			error("cannot write header");
+
+		/* Output symbol table. */
+		if (nsymbols != 0) {
+			if (hashsize > 1)
+				FPUTS("\n", tmpfp); /* offset zero */
+			for (i=0; i<hashsize; i++) {
+				symbol = symbols[i];
+				if (symbol) {
+					for (symbol = symbols[i]; symbol; symbol=symbol->next) {
+						if (sprintf(symbol->pos, "%lX\n", symbol->offset + indexsize)
+							!= symbol->digit+1)
+							error("something wrong with sprintf");
+						if (FPUTS(symbol->name, tmpfp) == EOF)
+							break;
+					}
+					if (hashsize > 1)
+						FPUTS("\n", tmpfp); /* end of bin */
+				}
+				if (FERROR(tmpfp))
+					error("failed to write to temp file");
+			}
+		}
+	}
+
+	/* Seek library file to 'begin'. */
+	if (FSEEK(fp, begin, SEEK_SET))
+		error("cannot seek file");
+
+	/* Copy the library content to temp file. */
+	while ((len = FREAD(line, 1, MAX_LINE_SIZE, fp)))
+		if (FWRITE(line, 1, len, tmpfp) != len)
+			error("cannot write temp file");
+	if (FERROR(fp))
+		error("cannot read file");
+
+	/* Close file. */
+	if (FCLOSE(fp))
+		error("closing file failed");
+
+#ifdef ZLIBARCH
+	/* We must reopen the temp file for reading, because zlib */
+	/* don't support reading and writing on the same file. */
+	err = FCLOSE(tmpfp);
+	tmpfp = NULL;
+	if (err)
+		error("closing temp file failed");
+	/* The temp file is opened for reading with pure stdio, */
+	/* we only do a file copy here. */
+	tmpfpr = fopen(tmpfilename, "r");
+	if (tmpfpr == NULL)
+		error("cannot open temp file");
+#else
+	/* No zlib, so set the temp file offet to zero. */
+	tmpfpr = tmpfp;
+	tmpfp = NULL;
+	if (fseek(tmpfpr, 0, SEEK_SET))
+		error("cannot seek temp file");
+#endif
+
+	/* From this point, if something goes wrong, */
+	/* the original library file may be lost. */
+
+	/* Delete old library file. */
+	if (remove(filename))
+		error("cannot remove file");
+
+	/* Create and open the new library file. */
+	fp = fopen(filename, "w");
+	if (fp == NULL)
+		error("cannot create file");
+
+	/* Copy temp file to new library file. */
+	while ((len = fread(line, 1, MAX_LINE_SIZE, tmpfpr)))
+		if (fwrite(line, 1, len, fp) != len)
+			error("cannot write file");
+	if (ferror(tmpfpr))
+		error("cannot read temp file");
+
+	/* Close library file. */
+	if (fclose(fp))
+		error("closing file failed");
+
+	/* Close temp file. */
+	if (fclose(tmpfpr))
+		error("closing temp file failed");
+
+	/* Cleanup temp file. */
+	cleanuptemp();
+
+	/* Free 'arch' and 'mach' if set. */
+	if (arch != NULL)
+		free(arch);
+	if (mach != NULL)
+		free(mach);
+
+	/* No filename for error printing. */
+	fname = NULL;
+}
+
+
+int main(int argc, char **argv)
+{
+	file_t *file;
+
+	/* No arguments? */
+	if (argc < 2)
+		usage(1);
+
+	/* Parse options. */
+	for (argv++, argc--; argc > 0; argv++, argc--) {
+		switch (*argv[0]) {
+		case '-':
+			if (!strcmp(*argv, OPT_HELP)) {
+				usage(0);
+			}
+			else
+			if (!strcmp(*argv, OPT_VERSION)) {
+				version();
+			}
+			else
+			if (!strncmp(*argv, OPT_ARCH, sizeof(OPT_ARCH)-1)) {
+				if (argv[0][sizeof(OPT_ARCH)-1] == 0) {
+					opt_arch = (char*)-1;
+					break;
+				}
+				if (argv[0][sizeof(OPT_ARCH)-1] == '=') {
+					opt_arch = &argv[0][sizeof(OPT_ARCH)];
+					if (!*opt_arch)
+						opt_arch = (char*)-1;
+					break;
+				}
+			}
+			else
+			if (!strncmp(*argv, OPT_MACH, sizeof(OPT_MACH)-1)) {
+				if (argv[0][sizeof(OPT_MACH)-1] == 0) {
+					opt_mach = (char*)-1;
+					break;
+				}
+				if (argv[0][sizeof(OPT_MACH)-1] == '=') {
+					opt_mach = &argv[0][sizeof(OPT_MACH)];
+					if (!*opt_mach)
+						opt_mach = (char*)-1;
+					break;
+				}
+			}
+			else
+			if (!strcmp(*argv, OPT_NOHASH)) {
+				opt_nohash = 1;
+				break;
+			}
+			else
+			if (!strcmp(*argv, OPT_STRIP)) {
+				opt_strip = 1;
+				break;
+			}
+			else
+			if (!strcmp(*argv, OPT_DETER)) {
+				opt_deterministic = 1;
+				break;
+			}
+			else
+			if (!strcmp(*argv, OPT_NONDETER)) {
+				opt_deterministic = 0;
+				break;
+			}
+#ifdef ZLIBARCH
+			else
+			if (!strcmp(*argv, OPT_GZIP)) {
+				opt_gzip = 1;
+				break;
+			}
+			else
+			if (!strcmp(*argv, OPT_NOGZIP)) {
+				opt_gzip = -1;
+				break;
+			}
+#endif
+			error("unrecognized option '%s'", *argv);
+			break;
+		default:
+			add_file(*argv);
+			break;
+		}
+	}
+
+	/* No files? */
+	if (files == NULL)
+		error("no file given");
+
+	/* Do ranlib() on files. */
+	for (file=files; file; file=file->next)
+		ranlib(file->name);
+
+	return 0;
+}
diff --git a/binutils/zlibarch.h b/binutils/zlibarch.h
new file mode 100644
index 0000000..79f2829
--- /dev/null
+++ b/binutils/zlibarch.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2016 by David Flamand <dflamand@gmail.com>
+ *
+ * This file is part of GCC6809.
+ *
+ * GCC6809 is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GCC6809 is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GCC6809; see the file COPYING3.  If not see
+ * <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _ZLIBARCH_H_
+# ifdef ZLIBARCH
+#  include <zlib.h>
+#  define FGETS(str, size, stream) (gzgets((gzFile)(stream), (str), (size)))
+#  define FSEEK(stream, offset, whence) ((long)(gzseek((gzFile)(stream), (z_off_t)(offset), (whence))<0?-1:0))
+#  define FOPEN(path, mode) ((FILE*)gzopen((path), (mode)))
+#  define FCLOSE(stream) (gzclose((gzFile)(stream))==Z_OK?0:-1)
+#  define FTELL(stream) ((long)gztell((gzFile)(stream)))
+#  define FEOF(stream) (gzeof((gzFile)(stream)))
+#  define FERROR(stream) (_gzerror((gzFile)(stream)))
+#  define FREAD(ptr, size, nmemb, stream) ((size_t)(gzread((gzFile)(stream), (ptr), (size)*(nmemb))/(size)))
+#  define FWRITE(ptr, size, nmemb, stream) ((size_t)(gzwrite((gzFile)(stream), (ptr), (size)*(nmemb))/(size)))
+#  define FPUTS(str, stream) (gzputs((gzFile)(stream), (str)))
+#  define FPRINTF(stream, ...) (gzprintf((gzFile)(stream), __VA_ARGS__))
+#  define FDOPEN(fd, mode) ((FILE*)gzdopen((fd), (mode)))
+#  define FDIRECT(stream) (gzdirect((gzFile)(stream)))
+#  if !defined(ZLIBARCH_STATIC) && !defined(ZLIBARCH_DEFINE)
+extern int _gzerror(gzFile file);
+#  endif
+#  ifdef ZLIBARCH_STATIC
+#   undef ZLIBARCH_STATIC
+#   undef ZLIBARCH_DEFINE
+#   define ZLIBARCH_STATIC static
+#   define ZLIBARCH_DEFINE
+#  else
+#   define ZLIBARCH_STATIC
+#  endif
+#  ifdef ZLIBARCH_DEFINE
+ZLIBARCH_STATIC int
+_gzerror(file)
+gzFile file;
+{
+	int errnum;
+	gzerror(file, &errnum);
+	return errnum < Z_OK;
+}
+#  endif
+# else
+#  define FGETS fgets
+#  define FSEEK fseek
+#  define FOPEN fopen
+#  define FCLOSE fclose
+#  define FTELL ftell
+#  define FEOF feof
+#  define FERROR ferror
+#  define FREAD fread
+#  define FWRITE fwrite
+#  define FPUTS fputs
+#  define FPRINTF fprintf
+#  define FDOPEN fdopen
+#  endif
+#endif
-- 
2.19.1.windows.1

