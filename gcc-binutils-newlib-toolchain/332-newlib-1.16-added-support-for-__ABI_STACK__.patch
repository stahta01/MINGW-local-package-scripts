From 8aa782d624f6bafe8712e7da96daf7b6b9aad178 Mon Sep 17 00:00:00 2001
From: dfffffff <dflamand@gmail.com>
Date: Wed, 3 Aug 2016 10:48:51 -0400
Subject: [PATCH 32/37] added support for __ABI_STACK__

---
 newlib/libc/machine/m6809/memcpy.S | 42 ++++++++++------
 newlib/libc/machine/m6809/memset.S | 51 ++++++++++++-------
 newlib/libc/machine/m6809/setjmp.S | 79 ++++++++++++++----------------
 3 files changed, 97 insertions(+), 75 deletions(-)

diff --git a/newlib/libc/machine/m6809/memcpy.S b/newlib/libc/machine/m6809/memcpy.S
index 138cc08..fdc6b6f 100644
--- a/newlib/libc/machine/m6809/memcpy.S
+++ b/newlib/libc/machine/m6809/memcpy.S
@@ -3,14 +3,12 @@
 ;;;
 ;;; memcpy for m6809
 ;;;
-;;;  support for -mdret
+;;;  support for -mdret and -mabi=stack
 ;;;  optimization: copy 2 byte at a time
-;;;
-;;;  TODO: support stack only args
 ;;;
 
-	.module memcpy.S
-	.area .text
+	.module	memcpy.S
+	.area	.text
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
@@ -18,28 +16,44 @@
 ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-	.globl _memcpy
+	.globl	_memcpy
 _memcpy:
+#ifdef __ABI_STACK__
+	pshs	u,y
+	ldd	10,s
+	beq	l2
+	ldu	8,s
+	ldy	6,s
+#else
 	pshs	u,y,x
 	ldd	10,s
-	beq	_l2
+	beq	l2
+	ldu	8,s
 	leay	,x
+#endif
 	tfr	d,x
-	ldu	8,s
 	bitb	#1
-	beq	_l1
+	beq	l1
 	ldb	,u+
 	stb	,y+
 	leax	-1,x
-	beq	_l2
-_l1:	ldd	,u++
+	beq	l2
+l1:	ldd	,u++
 	std	,y++
 	leax	-2,x
-	bne	_l1
-_l2:
+	bne	l1
+l2:
+#ifdef __ABI_STACK__
+#ifdef __DRET__
+	ldd	6,s
+#else
+	ldx	6,s
+#endif
+	puls	y,u,pc
+#else
 #ifdef __DRET__
 	puls	d,y,u,pc
 #else
 	puls	x,y,u,pc
 #endif
-
+#endif
diff --git a/newlib/libc/machine/m6809/memset.S b/newlib/libc/machine/m6809/memset.S
index c06c7a4..06fa9e0 100644
--- a/newlib/libc/machine/m6809/memset.S
+++ b/newlib/libc/machine/m6809/memset.S
@@ -3,14 +3,12 @@
 ;;;
 ;;; memset for m6809
 ;;;
-;;;  support for -mdret
+;;;  support for -mdret and -mabi=stack
 ;;;  optimization: set 2 byte at a time
-;;;
-;;;  TODO: support stack only args
 ;;;
 
-	.module memset.S
-	.area .text
+	.module	memset.S
+	.area	.text
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
@@ -18,27 +16,42 @@
 ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-	.globl _memset
+	.globl	_memset
 _memset:
-	pshs	y,x
+#ifdef __ABI_STACK__
+	pshs	u
+	ldd	8,s
+	beq	l3
+	ldu	4,s
+#else
+	pshs	u,x
 	ldd	8,s
-	beq	_l3
-	leay	,x
+	beq	l3
+	leau	,x
+#endif
 	tfr	d,x
 	lda	6+1,s
 	bitb	#1
-	beq	_l1
-	sta	,y+
+	beq	l1
+	sta	,u+
 	leax	-1,x
-	beq	_l3
-_l1:	tfr	a,b
-_l2:	std	,y++
+	beq	l3
+l1:	tfr	a,b
+l2:	std	,u++
 	leax	-2,x
-	bne	_l2
-_l3:
+	bne	l2
+l3:
+#ifdef __ABI_STACK__
 #ifdef __DRET__
-	puls	d,y,pc
+	ldd	4,s
 #else
-	puls	x,y,pc
+	ldx	4,s
+#endif
+	puls	u,pc
+#else
+#ifdef __DRET__
+	puls	d,u,pc
+#else
+	puls	x,u,pc
+#endif
 #endif
-
diff --git a/newlib/libc/machine/m6809/setjmp.S b/newlib/libc/machine/m6809/setjmp.S
index 7ca7333..d2c390f 100644
--- a/newlib/libc/machine/m6809/setjmp.S
+++ b/newlib/libc/machine/m6809/setjmp.S
@@ -2,7 +2,7 @@
 ;;; Copyright 2006 by Brian Dominy <brian@oddchange.com>
 ;;;
 ;;; Changes by David Flamand <dflamand@gmail.com> (May 2016)
-;;;  added support for -mdret
+;;;  added support for -mdret and -mabi=stack
 ;;;  added check for zero in longjmp return value
 ;;;  reduced size of jmp_buf
 ;;;  some optimizations
@@ -34,8 +34,8 @@ SAVE_DP_CC = 8
 
 SETJMP_S = 2
 
-	.module setjmp.S
-	.area .text
+	.module	setjmp.S
+	.area	.text
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
@@ -45,31 +45,28 @@ SETJMP_S = 2
 ; The return value is placed in X or D.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-	.globl _setjmp 
+	.globl	_setjmp
 _setjmp:
-	;-----------------------------------------------
-	; TODO: this sequence assumes that the
-	; function argument is passed directly in X.
-	; If all args go onto the stack, this is wrong.
-	;-----------------------------------------------
-	                      ; X = env
-	pshs u                ; Save nonvolatile U register
-	sty SAVE_Y,x          ; Save the Y register
-	stu SAVE_U,x          ; Save the U register
-	leau SETJMP_S+2,s
-	stu SAVE_S,x          ; Save the S register
-	ldd SETJMP_S,s
-	std SAVE_PC,x         ; Save the PC register
-	tfr dp,a
-	tfr cc,b
-	std SAVE_DP_CC,x      ; Save the DP/CC registers
+#ifdef __ABI_STACK__
+	ldx	2,s           ; X = env
+#endif
+	pshs	u             ; Save nonvolatile U register
+	sty	SAVE_Y,x      ; Save the Y register
+	stu	SAVE_U,x      ; Save the U register
+	leau	SETJMP_S+2,s
+	stu	SAVE_S,x      ; Save the S register
+	ldd	SETJMP_S,s
+	std	SAVE_PC,x     ; Save the PC register
+	tfr	dp,a
+	tfr	cc,b
+	std	SAVE_DP_CC,x  ; Save the DP/CC registers
 #ifdef __DRET__
 	clra                  ; Return zero in D
 	clrb
 #else
-	ldx #0                ; Return zero in X
+	ldx	#0            ; Return zero in X
 #endif
-	puls u,pc             ; Restore U and PC registers (returning)
+	puls	u,pc          ; Restore U and PC registers (returning)
 
 
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -80,28 +77,26 @@ _setjmp:
 ; val is placed on the stack.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
-	.globl _longjmp 
+	.globl	_longjmp
 _longjmp:
-	;-----------------------------------------------
-	; TODO: this sequence assumes that the first
-	; function argument is passed directly in X.
-	; If all args go onto the stack, this is wrong.
-	;-----------------------------------------------
-	                      ; X = env
-	ldd 2,s               ; D = val
-	bne _l1
+#ifdef __ABI_STACK__
+	ldx	2,s           ; X = env
+	ldd	4,s           ; D = val
+#else
+	ldd	2,s           ; D = val
+#endif
+	bne	l1
 	incb                  ; Zero is not allowed
-_l1:	lds SAVE_S,x          ; Restore the S register
-	ldu SAVE_PC,x         ; Load the PC register
-	pshs u,d              ; Save PC and return value onto stack
-	ldu SAVE_U,x          ; Restore the U register
-	ldy SAVE_Y,x          ; Restore the Y register
-	ldd SAVE_DP_CC,x      ; Load the DP/CC registers
-	tfr a,dp              ; Restore the DP register
-	tfr b,cc              ; Restore the CC register
+l1:	lds	SAVE_S,x      ; Restore the S register
+	ldu	SAVE_PC,x     ; Load the PC register
+	pshs	u,d           ; Save PC and return value onto stack
+	ldu	SAVE_U,x      ; Restore the U register
+	ldy	SAVE_Y,x      ; Restore the Y register
+	ldd	SAVE_DP_CC,x  ; Load the DP/CC registers
+	tfr	a,dp          ; Restore the DP register
+	tfr	b,cc          ; Restore the CC register
 #ifdef __DRET__
-	puls d,pc             ; Restore D and PC registers (returning)
+	puls	d,pc          ; Restore D and PC registers (returning)
 #else
-	puls x,pc             ; Restore X and PC registers (returning)
+	puls	x,pc          ; Restore X and PC registers (returning)
 #endif
-
-- 
2.19.1.windows.1

